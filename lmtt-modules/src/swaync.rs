use crate::{ThemeModule, ConfigFileInfo};
use async_trait::async_trait;
use lmtt_core::{ColorScheme, Config, Result};

crate::register_module!(SwayNCModule);

pub struct SwayNCModule;

impl SwayNCModule {
    pub fn new() -> Self {
        Self
    }
}

#[async_trait]
impl ThemeModule for SwayNCModule {
    fn name(&self) -> &'static str {
        "swaync"
    }

    fn binary_name(&self) -> &'static str {
        "swaync"
    }

    async fn apply(&self, scheme: &ColorScheme, _config: &Config) -> Result<()> {
        let colors_file = dirs::config_dir()
            .ok_or(lmtt_core::Error::Config("No config dir".into()))?
            .join("swaync")
            .join("lmtt-colors.css");

        if let Some(parent) = colors_file.parent() {
            tokio::fs::create_dir_all(parent).await?;
        }

        // Extract colors with defaults
        let default_surface = "#12131a".to_string();
        let default_surface_container = "#1e1f29".to_string();
        let default_on_surface = "#e3e1ec".to_string();
        let default_primary = "#9fd491".to_string();
        let default_on_primary = "#083906".to_string();
        let default_error = "#ffb4ab".to_string();
        let default_on_error = "#690005".to_string();
        let default_outline = "#8f909f".to_string();

        let surface = scheme.get("surface").unwrap_or(&default_surface);
        let surface_container = scheme.get("surface_container").unwrap_or(&default_surface_container);
        let on_surface = scheme.get("on_surface").unwrap_or(&default_on_surface);
        let on_surface_variant = scheme.get("on_surface_variant").unwrap_or(&default_on_surface);
        let primary = scheme.get("primary").unwrap_or(&default_primary);
        let on_primary = scheme.get("on_primary").unwrap_or(&default_on_primary);
        let error = scheme.get("error").unwrap_or(&default_error);
        let on_error = scheme.get("on_error").unwrap_or(&default_on_error);
        let outline = scheme.get("outline").unwrap_or(&default_outline);

        // Generate SwayNC color definitions only
        let css = format!(r#"/* SwayNC colors generated by lmtt */
@define-color cc-bg {};
@define-color noti-bg {};
@define-color noti-bg-opaque {};
@define-color noti-border-color transparent;
@define-color noti-close-bg {};
@define-color noti-close-bg-hover {};
@define-color text-color {};
@define-color text-color-disabled {};
@define-color bg-selected {};
@define-color on-primary {};
@define-color on-error {};
@define-color outline {};
@define-color surface-container {};
"#, surface, surface, surface, error, error, on_surface, on_surface_variant, primary, on_primary, on_error, outline, surface_container);

        tokio::fs::write(&colors_file, css).await?;

        // Reload SwayNC
        tokio::process::Command::new("swaync-client")
            .arg("--reload-css")
            .output()
            .await
            .ok();

        tracing::info!("[SwayNC] Updated colors at {}", colors_file.display());

        Ok(())
    }

    async fn config_files(&self) -> Result<Vec<ConfigFileInfo>> {
        let style_css = dirs::config_dir()
            .ok_or(lmtt_core::Error::Config("No config dir".into()))?
            .join("swaync")
            .join("style.css");

        if !style_css.exists() {
            return Ok(vec![]);
        }

        let content = tokio::fs::read_to_string(&style_css).await.unwrap_or_default();
        let include_line = "@import url('lmtt-colors.css');";

        Ok(vec![ConfigFileInfo {
            path: style_css,
            include_line: include_line.to_string(),
            description: "Import lmtt colors into SwayNC CSS".to_string(),
            already_included: content.contains(include_line),
        }])
    }
}
