use crate::{ThemeModule, ConfigFileInfo};
use async_trait::async_trait;
use lmtt_core::{ColorScheme, Config, Result};

crate::register_module!(FishModule);

pub struct FishModule;

impl FishModule {
    pub fn new() -> Self {
        Self
    }
}

#[async_trait]
impl ThemeModule for FishModule {
    fn name(&self) -> &'static str {
        "fish"
    }
    
    fn binary_name(&self) -> &'static str {
        "fish"
    }
    
    async fn apply(&self, scheme: &ColorScheme, _config: &Config) -> Result<()> {
        let colors_file = dirs::config_dir()
            .ok_or(lmtt_core::Error::Config("No config dir".into()))?
            .join("fish")
            .join("conf.d")
            .join("lmtt-colors.fish");
        
        if let Some(parent) = colors_file.parent() {
            tokio::fs::create_dir_all(parent).await?;
        }
        
        let default_fg = "#e3e1ec".to_string();
        let default_primary = "#9fd491".to_string();
        let default_secondary = "#edb8cd".to_string();
        let default_outline = "#8f909f".to_string();
        let default_error = "#ffb4ab".to_string();
        let default_tertiary = "#bbc3fa".to_string();
        let default_tertiary_container = "#3b4472".to_string();
        let default_surface_container_high = "#292931".to_string();
        
        let on_surface = scheme.get("on_surface").unwrap_or(&default_fg);
        let primary = scheme.get("primary").unwrap_or(&default_primary);
        let secondary = scheme.get("secondary").unwrap_or(&default_secondary);
        let outline = scheme.get("outline").unwrap_or(&default_outline);
        let error = scheme.get("error").unwrap_or(&default_error);
        let on_surface_variant = scheme.get("on_surface_variant").unwrap_or(&default_fg);
        let primary_container = scheme.get("primary_container").unwrap_or(&default_primary);
        let tertiary = scheme.get("tertiary").unwrap_or(&default_tertiary);
        let tertiary_container = scheme.get("tertiary_container").unwrap_or(&default_tertiary_container);
        let surface_container_high = scheme.get("surface_container_high").unwrap_or(&default_surface_container_high);
        
        let mut content = String::new();
        content.push_str("# Fish shell colors generated by lmtt\n\n");
        content.push_str(&format!("set -g fish_color_normal '{}'\n", on_surface));
        content.push_str(&format!("set -g fish_color_command '{}'\n", primary));
        content.push_str(&format!("set -g fish_color_param '{}'\n", on_surface));
        content.push_str(&format!("set -g fish_color_redirection '{}'\n", secondary));
        content.push_str(&format!("set -g fish_color_comment '{}'\n", outline));
        content.push_str(&format!("set -g fish_color_error '{}'\n", error));
        content.push_str(&format!("set -g fish_color_escape '{}'\n", tertiary));
        content.push_str(&format!("set -g fish_color_operator '{}'\n", primary));
        content.push_str(&format!("set -g fish_color_quote '{}'\n", secondary));
        content.push_str(&format!("set -g fish_color_autosuggestion '{}'\n", outline));
        content.push_str(&format!("set -g fish_color_selection --background='{}'\n", primary_container));
        content.push_str(&format!("set -g fish_color_search_match --background='{}'\n", tertiary_container));
        content.push_str(&format!("set -g fish_pager_color_completion '{}'\n", on_surface));
        content.push_str(&format!("set -g fish_pager_color_description '{}'\n", on_surface_variant));
        content.push_str(&format!("set -g fish_pager_color_prefix '{}'\n", primary));
        content.push_str(&format!("set -g fish_pager_color_progress '{}'\n", outline));
        content.push_str(&format!("set -g fish_pager_color_selected_background --background='{}'\n", surface_container_high));
        
        tokio::fs::write(&colors_file, content).await?;
        
        tracing::info!("[Fish] Updated colors at {}", colors_file.display());
        
        Ok(())
    }
    
    async fn config_files(&self) -> Result<Vec<ConfigFileInfo>> {
        Ok(vec![])
    }
}
