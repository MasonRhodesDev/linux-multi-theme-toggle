use crate::{ThemeModule, ConfigFileInfo};
use async_trait::async_trait;
use lmtt_core::{ColorScheme, Config, Result};

crate::register_module!(HyprlandModule);

pub struct HyprlandModule;

impl HyprlandModule {
    pub fn new() -> Self {
        Self
    }
}

#[async_trait]
impl ThemeModule for HyprlandModule {
    fn name(&self) -> &'static str {
        "hyprland"
    }
    
    fn binary_name(&self) -> &'static str {
        "hyprctl"
    }
    
    fn priority(&self) -> u8 {
        100
    }
    
    async fn apply(&self, scheme: &ColorScheme, _config: &Config) -> Result<()> {
        let colors_conf = dirs::config_dir()
            .ok_or(lmtt_core::Error::Config("No config dir".into()))?
            .join("hypr")
            .join("colors.conf");
        
        // Ensure directory exists
        if let Some(parent) = colors_conf.parent() {
            tokio::fs::create_dir_all(parent).await?;
        }
        
        // Generate Hyprland colors.conf
        let mut content = String::new();
        content.push_str("# Material You colors generated by lmtt\n");
        content.push_str(&format!("# Mode: {}\n\n", scheme.mode));
        
        // Extract key colors with owned defaults
        let default_primary = "#9fd491".to_string();
        let default_surface = "#12131a".to_string();
        let default_on_surface = "#e3e1ec".to_string();
        
        let primary = scheme.get("primary").unwrap_or(&default_primary);
        let surface = scheme.get("surface").unwrap_or(&default_surface);
        let on_surface = scheme.get("on_surface").unwrap_or(&default_on_surface);
        
        // Remove # from colors
        let primary = primary.trim_start_matches('#');
        let surface = surface.trim_start_matches('#');
        let on_surface = on_surface.trim_start_matches('#');
        
        content.push_str(&format!("$primary = rgb({})\n", primary));
        content.push_str(&format!("$surface = rgb({})\n", surface));
        content.push_str(&format!("$on_surface = rgb({})\n", on_surface));
        content.push_str("\n");
        content.push_str("# Use these variables in your hyprland.conf:\n");
        content.push_str("# general:col.active_border = $primary\n");
        content.push_str("# general:col.inactive_border = $surface\n");
        
        tokio::fs::write(&colors_conf, content).await?;
        
        tracing::info!("[Hyprland] Updated colors at {}", colors_conf.display());
        
        Ok(())
    }
    
    async fn config_files(&self) -> Result<Vec<ConfigFileInfo>> {
        let config_dir = dirs::config_dir()
            .ok_or(lmtt_core::Error::Config("No config dir".into()))?;
        
        let hyprland_conf = config_dir.join("hypr").join("hyprland.conf");
        
        if !hyprland_conf.exists() {
            return Ok(vec![]);
        }
        
        // Check if already included
        let content = tokio::fs::read_to_string(&hyprland_conf).await?;
        let include_line = "source = ~/.config/hypr/colors.conf";
        let already_included = content.contains(include_line);
        
        Ok(vec![ConfigFileInfo {
            path: hyprland_conf,
            include_line: include_line.to_string(),
            description: "Source lmtt colors in Hyprland config".to_string(),
            already_included,
        }])
    }
}
