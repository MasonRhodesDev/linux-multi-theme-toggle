use crate::{ThemeModule, ConfigFileInfo};
use async_trait::async_trait;
use lmtt_core::{ColorScheme, Config, Result};

crate::register_module!(WeztermModule);

pub struct WeztermModule;

impl WeztermModule {
    pub fn new() -> Self {
        Self
    }
}

#[async_trait]
impl ThemeModule for WeztermModule {
    fn name(&self) -> &'static str {
        "wezterm"
    }
    
    fn binary_name(&self) -> &'static str {
        "wezterm"
    }
    
    async fn apply(&self, scheme: &ColorScheme, config: &Config) -> Result<()> {
        let config_dir = dirs::config_dir()
            .ok_or(lmtt_core::Error::Config("No config dir".into()))?
            .join("wezterm");
        
        let colors_file = config_dir.join("lmtt-colors.lua");
        
        if let Some(parent) = colors_file.parent() {
            tokio::fs::create_dir_all(parent).await?;
        }
        
        let is_light = scheme.get("mode").map(|m| m == "light").unwrap_or(false);
        let profile = if is_light {
            &config.theme_profiles.light
        } else {
            &config.theme_profiles.dark
        };
        
        let default_fg = "#e3e1ec".to_string();
        let default_bg = "#12131a".to_string();
        let default_primary = "#9fd491".to_string();
        let default_error = "#ffb4ab".to_string();
        let default_outline = "#8f909f".to_string();
        let default_surface_container = "#292931".to_string();
        
        let foreground = scheme.get("on_surface").unwrap_or(&default_fg);
        let background = scheme.get("surface").unwrap_or(&default_bg);
        let cursor_bg = scheme.get("primary").unwrap_or(&default_primary);
        let cursor_fg = scheme.get("on_primary").unwrap_or(&default_bg);
        let selection_bg = scheme.get("primary_container").unwrap_or(&default_primary);
        let selection_fg = scheme.get("on_primary_container").unwrap_or(&default_bg);
        let outline = scheme.get("outline").unwrap_or(&default_outline);
        let error = scheme.get("error").unwrap_or(&default_error);
        let on_surface_variant = scheme.get("on_surface_variant").unwrap_or(&default_fg);
        
        let ansi = vec![
            outline.clone(),
            error.clone(),
            "#2e7d32".to_string(),  // green
            "#f57c00".to_string(),  // yellow
            cursor_bg.clone(),
            on_surface_variant.clone(),
            "#7d5260".to_string(),  // cyan
            foreground.clone(),
        ];
        
        let brights = vec![
            scheme.get("surface_container_high").unwrap_or(&default_surface_container).clone(),
            error.clone(),
            "#388e3c".to_string(),  // bright green
            "#ff9800".to_string(),  // bright yellow
            cursor_bg.clone(),
            on_surface_variant.clone(),
            "#7d5260".to_string(),  // bright cyan
            foreground.clone(),
        ];
        
        let mut content = String::new();
        content.push_str("-- WezTerm colors generated by lmtt\n");
        content.push_str("return {\n");
        content.push_str(&format!("  foreground = '{}',\n", foreground));
        content.push_str(&format!("  background = '{}',\n", background));
        content.push_str(&format!("  cursor_bg = '{}',\n", cursor_bg));
        content.push_str(&format!("  cursor_fg = '{}',\n", cursor_fg));
        content.push_str(&format!("  cursor_border = '{}',\n", cursor_bg));
        content.push_str(&format!("  selection_fg = '{}',\n", selection_fg));
        content.push_str(&format!("  selection_bg = '{}',\n", selection_bg));
        content.push_str("  ansi = {\n");
        for color in &ansi {
            content.push_str(&format!("    '{}',\n", color));
        }
        content.push_str("  },\n");
        content.push_str("  brights = {\n");
        for color in &brights {
            content.push_str(&format!("    '{}',\n", color));
        }
        content.push_str("  },\n");
        content.push_str("}\n");
        
        tokio::fs::write(&colors_file, content).await?;
        tracing::info!("[WezTerm] Updated colors at {}", colors_file.display());
        
        let profile_file = config_dir.join("lmtt-profile.lua");
        let mut profile_content = String::new();
        profile_content.push_str("-- WezTerm profile settings generated by lmtt\n");
        profile_content.push_str("return {\n");
        
        if let Some(font) = &profile.terminal_font {
            profile_content.push_str(&format!("  font = '{}',\n", font));
        }
        profile_content.push_str(&format!("  font_size = {},\n", profile.terminal_font_size));
        profile_content.push_str(&format!("  opacity = {},\n", profile.terminal_opacity));
        profile_content.push_str(&format!("  blur = {},\n", profile.window_blur));
        profile_content.push_str("}\n");
        
        tokio::fs::write(&profile_file, profile_content).await?;
        tracing::info!("[WezTerm] Updated profile settings at {}", profile_file.display());
        
        Ok(())
    }
    
    async fn config_files(&self) -> Result<Vec<ConfigFileInfo>> {
        let config_dir = dirs::config_dir()
            .ok_or(lmtt_core::Error::Config("No config dir".into()))?;
        
        let wezterm_lua = config_dir.join("wezterm/wezterm.lua");
        
        if !wezterm_lua.exists() {
            return Ok(vec![]);
        }
        
        let content = tokio::fs::read_to_string(&wezterm_lua).await?;
        let include_line = "local colors = require('lmtt-colors')";
        let already_included = content.contains(include_line);
        
        Ok(vec![ConfigFileInfo {
            path: wezterm_lua,
            include_line: include_line.to_string(),
            description: "Require lmtt-colors in wezterm config".to_string(),
            already_included,
        }])
    }
}
